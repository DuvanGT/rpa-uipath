name: UiPath CI/CD Pipeline

on:
  push:
    branches: [ main ] # Se ejecuta cada vez que subes algo a main

jobs:
  build:
    runs-on: windows-latest # Importante: UiPath requiere Windows para compilar
    
    steps:
      - name: Checkout del código
        uses: actions/checkout@v3
      
      - name: Ejecutar Robot (Simulación de Log)
        run: |
          echo "Iniciando Robot..."
          echo "Hola Mundo desde el Pipeline de GitHub"
          echo "Ajuste"
      # Empaquetado (sin acción externa): crear carpeta output y comprimir el proyecto
# Empaquetado oficial usando UiPath CLI (Versión .NET)
      - name: Pack Robot (Compilar Oficialmente)
        shell: powershell
        run: |
          $version = "1.0.${{ github.run_number }}"
          $outputDir = "output"
          New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
          
          Write-Host "1. Preparando el manifiesto de herramientas .NET..."
          # Crea un entorno local para instalar herramientas de forma segura
          dotnet new tool-manifest
          
          Write-Host "2. Instalando UiPath CLI oficial..."
          # Descarga la herramienta en su nuevo formato DotnetTool
          dotnet tool install UiPath.CLI.Windows
          
          Write-Host "3. Empaquetando el proyecto con la estructura correcta..."
          # Usamos 'dotnet tool run' para ejecutar uipcli sin problemas de rutas
          dotnet tool run uipcli package pack project.json -o $outputDir -v $version
          
          Write-Host "¡Empaquetado listo! Verificando archivo:"
          Get-ChildItem -Path $outputDir

      - name: Guardar el artefacto compilado
        uses: actions/upload-artifact@v4
        with:
          name: RobotCompilado
          path: output/
  deploy:
    needs: build
    runs-on: windows-latest # Importante: UiPath requiere Windows para compilar
    
    steps:
      - name: Checkout del código
        uses: actions/checkout@v3
      
      - name: Descargar artefacto compilado
        uses: actions/download-artifact@v4
        with:
          name: RobotCompilado
          path: output/
      
      # - name: Desplegar paquete al Orchestrator
      #   uses: UiPath/uipath-automation-deploy@v4
      #   with:
      #     orchestratorUrl: 'https://cloud.uipath.com'
      #     orchestratorTenant: 'DefaultTenant'  # Cambia esto si tu Tenant tiene otro nombre
      #     accountName: ${{ secrets.UIPATH }}
      #     clientId: ${{ secrets.APP_ID }}
      #     clientSecret: ${{ secrets.APP_SECRET }}
      #     # Aquí le decimos que busque el archivo en la carpeta donde lo descargaste
      #     packagePath: 'output' 
      #     folderName: 'Shared' # La carpeta del Orchestrator (Shared es la estándar)
      # - name: Desplegar paquete al Orchestrator (Automation Cloud)
      #   shell: powershell
      #   env:
      #     UIPATH_ACCOUNT_LOGICAL_NAME: ${{ secrets.UIPATH }}
      #     UIPATH_TENANT_NAME: DefaultTenant
      #     UIPATH_CLIENT_ID: ${{ secrets.APP_ID }}
      #     UIPATH_CLIENT_SECRET: ${{ secrets.APP_SECRET }}
      #   run: |
      #     Write-Host "Buscando .nupkg en output/"
      #     $pkg = Get-ChildItem -Path output -Filter *.nupkg | Select-Object -First 1
      #     if (-not $pkg) {
      #       Write-Error "No se encontró ningún .nupkg en output/"
      #       exit 1
      #     }
      #     Write-Host "Encontrado paquete: $($pkg.Name)"

      #     $account = $env:UIPATH_ACCOUNT_LOGICAL_NAME
      #     $tenant = $env:UIPATH_TENANT_NAME
      #     $clientId = $env:UIPATH_CLIENT_ID
      #     $clientSecret = $env:UIPATH_CLIENT_SECRET
      #     if (-not ($account -and $tenant -and $clientId -and $clientSecret)) {
      #       Write-Error "Faltan secretos necesarios. Añade UIPATH_ACCOUNT_LOGICAL_NAME, UIPATH_TENANT_NAME, UIPATH_CLIENT_ID, UIPATH_CLIENT_SECRET"
      #       exit 1
      #     }

      #     Write-Host "Autenticando en Account API..."
      #     $tokenEndpoint = 'https://account.uipath.com/oauth/token'
      #     $body = @{
      #       grant_type = 'client_credentials'
      #       client_id = $clientId
      #       client_secret = $clientSecret
      #     }
      #     try {
      #       $resp = Invoke-RestMethod -Method Post -Uri $tokenEndpoint -Body $body -ContentType 'application/x-www-form-urlencoded'
      #     } catch {
      #       Write-Error "Error authenticating: $_"
      #       exit 1
      #     }
      #     $accessToken = $resp.access_token
      #     if (-not $accessToken) { Write-Error "No se obtuvo access_token desde Account API"; exit 1 }

      #     $orchUploadUrl = "https://cloud.uipath.com/$account/$tenant/orchestrator_/odata/Packages/UiPath.Server.Configuration.OData.UploadPackage"
      #     Write-Host "Subiendo paquete a: $orchUploadUrl"

      #     # Construir multipart/form-data manualmente
      #     $filePath = $pkg.FullName
      #     $fileName = $pkg.Name
      #     $boundary = [System.Guid]::NewGuid().ToString()
      #     $LF = "`r`n"
      #     $header = "--$boundary$LF" + "Content-Disposition: form-data; name=`"file`"; filename=`"$fileName`"$LF" + "Content-Type: application/octet-stream$LF$LF"
      #     $footer = "$LF--$boundary--$LF"

      #     $fileBytes = [System.IO.File]::ReadAllBytes($filePath)
      #     $enc = [System.Text.Encoding]::UTF8
      #     $mem = New-Object System.IO.MemoryStream
      #     $writer = New-Object System.IO.StreamWriter($mem, $enc)
      #     $writer.Write($header)
      #     $writer.Flush()
      #     $mem.Write($fileBytes, 0, $fileBytes.Length)
      #     $writer.Write($footer)
      #     $writer.Flush()
      #     $mem.Position = 0

      #     $client = New-Object System.Net.Http.HttpClient
      #     $client.DefaultRequestHeaders.Add('Authorization', "Bearer $accessToken")
      #     $content = New-Object System.Net.Http.StreamContent($mem)
      #     $content.Headers.ContentType = [System.Net.Http.Headers.MediaTypeHeaderValue]::Parse("multipart/form-data; boundary=$boundary")
      #     $response = $client.PostAsync($orchUploadUrl, $content).Result
      #     $respBody = $response.Content.ReadAsStringAsync().Result
      #     if ($response.IsSuccessStatusCode) {
      #       Write-Host "Paquete subido correctamente. Response: $respBody"
      #     } else {
      #       Write-Error "Error subiendo paquete: $($response.StatusCode) - $respBody"
      #       exit 1
      #     }

      # - name: Desplegar paquete al Orchestrator (Automation Cloud)
      #   shell: pwsh
      #   env:
      #     UIPATH_ACCOUNT_LOGICAL_NAME: ${{ secrets.UIPATH }}
      #     UIPATH_TENANT_NAME: DefaultTenant
      #     UIPATH_CLIENT_ID: ${{ secrets.APP_ID }}
      #     UIPATH_CLIENT_SECRET: ${{ secrets.APP_SECRET }}
      #   run: |
      #     Write-Host "Buscando .nupkg en output/"
      #     $pkg = Get-ChildItem -Path output -Filter *.nupkg | Select-Object -First 1
      #     if (-not $pkg) {
      #       Write-Error "No se encontró ningún .nupkg en output/"
      #       exit 1
      #     }
      #     Write-Host "Encontrado paquete: $($pkg.Name)"

      #     $account = $env:UIPATH_ACCOUNT_LOGICAL_NAME
      #     $tenant = $env:UIPATH_TENANT_NAME
      #     $clientId = $env:UIPATH_CLIENT_ID
      #     $clientSecret = $env:UIPATH_CLIENT_SECRET
      #     if (-not ($account -and $tenant -and $clientId -and $clientSecret)) {
      #       Write-Error "Faltan secretos necesarios. Añade UIPATH_ACCOUNT_LOGICAL_NAME, UIPATH_TENANT_NAME, UIPATH_CLIENT_ID, UIPATH_CLIENT_SECRET"
      #       exit 1
      #     }

      #     Write-Host "Autenticando en Identity API de UiPath..."
      #     $tokenEndpoint = 'https://cloud.uipath.com/identity_/connect/token'
      #     $body = @{
      #       grant_type = 'client_credentials'
      #       client_id = $clientId
      #       client_secret = $clientSecret
      #       scope = 'OR.Execution OR.Folders'
      #     }
      #     try {
      #       $resp = Invoke-RestMethod -Method Post -Uri $tokenEndpoint -Body $body -ContentType 'application/x-www-form-urlencoded'
      #     } catch {
      #       Write-Error "Error authenticating: $_"
      #       exit 1
      #     }
      #     $accessToken = $resp.access_token
      #     if (-not $accessToken) { Write-Error "No se obtuvo access_token desde Identity API"; exit 1 }

      #     $orchUploadUrl = "https://cloud.uipath.com/$account/$tenant/orchestrator_/odata/Processes/UiPath.Server.Configuration.OData.UploadPackage"
      #     Write-Host "Subiendo paquete a: $orchUploadUrl"

      #     # NUEVA FORMA: Subida nativa y limpia compatible con GitHub Actions
      #     $filePath = $pkg.FullName
          
      #     $headers = @{
      #         Authorization = "Bearer $accessToken"
      #     }
          
      #     $form = @{
      #         file = Get-Item -Path $filePath
      #     }
          
      #     try {
      #         $uploadResp = Invoke-RestMethod -Method Post -Uri $orchUploadUrl -Headers $headers -Form $form
      #         Write-Host "¡Paquete subido correctamente al Orchestrator!"
      #     } catch {
      #         Write-Error "Error subiendo paquete: $_"
      #         # Si UiPath rechaza el paquete, esto nos dirá exactamente por qué
      #         if ($_.ErrorDetails) {
      #             Write-Error "Detalles de UiPath: $($_.ErrorDetails.Message)"
      #         }
      #         exit 1
      #     }

      - name: Desplegar paquete al Orchestrator (Automation Cloud)
        shell: pwsh
        env:
          UIPATH_ACCOUNT_LOGICAL_NAME: ${{ secrets.UIPATH }}
          UIPATH_TENANT_NAME: DefaultTenant
          UIPATH_CLIENT_ID: ${{ secrets.APP_ID }}
          UIPATH_CLIENT_SECRET: ${{ secrets.APP_SECRET }}
        run: |
          Write-Host "Buscando .nupkg en output/"
          $pkg = Get-ChildItem -Path output -Filter *.nupkg | Select-Object -First 1
          if (-not $pkg) {
            Write-Error "No se encontró ningún .nupkg en output/"
            exit 1
          }
          Write-Host "Encontrado paquete: $($pkg.Name)"

          $account = $env:UIPATH_ACCOUNT_LOGICAL_NAME
          $tenant = $env:UIPATH_TENANT_NAME
          $clientId = $env:UIPATH_CLIENT_ID
          $clientSecret = $env:UIPATH_CLIENT_SECRET
          if (-not ($account -and $tenant -and $clientId -and $clientSecret)) {
            Write-Error "Faltan secretos necesarios. Añade UIPATH_ACCOUNT_LOGICAL_NAME, UIPATH_TENANT_NAME, UIPATH_CLIENT_ID, UIPATH_CLIENT_SECRET"
            exit 1
          }

          Write-Host "Autenticando en Identity API de UiPath..."
          $tokenEndpoint = 'https://cloud.uipath.com/identity_/connect/token'
          $body = @{
            grant_type = 'client_credentials'
            client_id = $clientId
            client_secret = $clientSecret
            scope = 'OR.Execution OR.Folders'
          }
          try {
            $resp = Invoke-RestMethod -Method Post -Uri $tokenEndpoint -Body $body -ContentType 'application/x-www-form-urlencoded'
          } catch {
            Write-Error "Error authenticating: $_"
            exit 1
          }
          $accessToken = $resp.access_token
          if (-not $accessToken) { Write-Error "No se obtuvo access_token desde Identity API"; exit 1 }

          $orchUploadUrl = "https://cloud.uipath.com/$account/$tenant/orchestrator_/odata/Processes/UiPath.Server.Configuration.OData.UploadPackage"
          Write-Host "Subiendo paquete a: $orchUploadUrl"

          $filePath = $pkg.FullName
          $fileSize = (Get-Item $filePath).Length
          Write-Host "Tamaño del archivo a subir: $fileSize bytes"
          
          # Validación de seguridad para evitar el error 1654 por archivo vacío
          if ($fileSize -eq 0) {
              Write-Error "¡Alto ahí! El archivo .nupkg está vacío (0 bytes). Revisa el paso de tu pipeline donde descargas el artefacto."
              exit 1
          }

          Write-Host "Ejecutando subida con curl.exe para formateo perfecto..."
          # Usamos curl.exe nativo que jamás falla con el formato multipart
          $httpCode = curl.exe -s -w "%{http_code}" -o result.json -X POST "$orchUploadUrl" -H "Authorization: Bearer $accessToken" -F "file=@$filePath"
          
          $responseBody = Get-Content result.json -Raw
          Write-Host "Código HTTP devuelto: $httpCode"
          Write-Host "Respuesta de UiPath: $responseBody"

          if ($httpCode -match '^20') {
              Write-Host "¡BINGO! Paquete subido correctamente al Orchestrator."
          } else {
              Write-Error "Error subiendo paquete. Revisa la respuesta arriba."
              exit 1
          }